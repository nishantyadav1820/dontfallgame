<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Don't Fall - Customizable Strikes & Themes</title>
  <style>
    /* Basic styling */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #e0f7fa;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    canvas {
      border: 2px solid #333;
      display: block;
      background: #fff;
    }
    /* Menu styling */
    .menu {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      animation: fadeIn 0.5s ease;
    }
    .menu.hidden {
      display: none;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .menu h1, .menu h2, .menu h3 {
      margin: 10px;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #00796b;
      color: #fff;
      transition: background-color 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    button:hover {
      background-color: #004d40;
    }
    label {
      margin: 10px;
      display: block;
    }
    input[type="range"], input[type="color"], select {
      margin-left: 10px;
    }
    /* In-game UI overlay */
    #gameUI {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
      pointer-events: none;
      font-family: 'Press Start 2P', cursive;
    }
    #gameUI div {
      pointer-events: auto;
    }
    #scoreDisplay, #strikesDisplay {
      font-size: 24px;
      padding: 15px 25px;
      border-radius: 15px;
      margin-right: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.18);
      transition: all 0.3s ease;
      letter-spacing: 1px;
    }
    #scoreDisplay {
      border-left: 4px solid #4CAF50;
      animation: scorePulse 2s infinite;
    }
    #strikesDisplay {
      border-left: 4px solid #f44336;
      animation: strikePulse 2s infinite;
    }
    #gameUI button {
      font-family: 'Press Start 2P', cursive;
      font-size: 16px;
      padding: 12px 24px;
      margin-left: 15px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      color: #fff;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
    }
    #gameUI button::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
      );
      transform: rotate(45deg);
      transition: 0.5s;
      opacity: 0;
    }
    #gameUI button:hover::before {
      opacity: 1;
      animation: shine 1s forwards;
    }
    @keyframes shine {
      0% {
        transform: rotate(45deg) translateY(0);
      }
      100% {
        transform: rotate(45deg) translateY(100%);
      }
    }
    #gameUI button:hover {
      transform: translateY(-2px);
      filter: brightness(1.1);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.2);
      color: #fff2f2;
    }
    #gameUI button:active {
      transform: translateY(1px);
      filter: brightness(0.9);
      color: #ffe0e0;
    }
    #pauseButton {
      background: linear-gradient(45deg, #ff4757, #ff6b81);
      border-left: 4px solid #ff4757;
      box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
      color: #2f3542;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
      font-weight: bold;
    }
    #settingsButton {
      background: linear-gradient(45deg, #2ed573, #7bed9f);
      border-left: 4px solid #2ed573;
      box-shadow: 0 4px 15px rgba(46, 213, 115, 0.4);
      color: #2f3542;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
      font-weight: bold;
    }
    @keyframes scorePulse {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
      100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
    }
    @keyframes strikePulse {
      0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
      100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
    }
    /* Add theme-specific glow effects */
    .theme-neon #scoreDisplay { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
    .theme-cyber #scoreDisplay { text-shadow: 0 0 10px #e94560, 0 0 20px #e94560; }
    .theme-synthwave #scoreDisplay { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      #gameUI {
        flex-wrap: wrap;
        gap: 10px;
      }
      
      #scoreDisplay, #strikesDisplay {
        font-size: 18px;
        padding: 10px 15px;
      }
      
      #gameUI button {
        font-size: 14px;
        padding: 10px 20px;
        margin-left: 10px;
      }
    }
    .menu h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 3rem;
      color: #ff0;
      text-shadow: 4px 4px #f00, 
                   -4px -4px #0ff;
      margin-bottom: 30px;
      animation: titlePulse 2s infinite;
    }

    @font-face {
      font-family: 'Press Start 2P';
      src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    }

    .retro-text {
      font-family: 'Courier New', monospace;
      color: #fff;
      text-shadow: 2px 2px #000;
      font-size: 1.2rem;
      margin: 10px 0;
    }

    .how-to-play {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #fff;
      border-radius: 10px;
      padding: 20px;
      margin: 20px;
      max-width: 600px;
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }

    .control-key {
      background: #fff;
      color: #000;
      padding: 10px 20px;
      border-radius: 5px;
      font-weight: bold;
      box-shadow: 0 4px #999;
    }

    .tips-container {
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%);
      text-align: center;
      color: #fff;
      font-style: italic;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 20px;
      backdrop-filter: blur(5px);
      width: 50%;
      min-width: 300px;
      max-width: 800px;
      z-index: 10;
    }

    .tips-container .retro-text {
      font-size: 1.1rem;
      line-height: 1.4;
      margin: 0;
      padding: 5px 0;
    }

    @keyframes titlePulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .rainbow-border {
      border: 4px solid;
      border-image: linear-gradient(45deg, 
        #ff0000, #ff7f00, #ffff00, #00ff00, 
        #0000ff, #4b0082, #8f00ff) 1;
      animation: borderRotate 4s linear infinite;
    }

    @keyframes borderRotate {
      100% { filter: hue-rotate(360deg); }
    }

    .floating {
      animation: float 3s ease-in-out infinite;
    }

    .glowing {
      animation: glow 2s ease-in-out infinite;
    }

    .bouncing {
      animation: bounce 0.5s ease infinite;
    }

    .sliding {
      animation: slide 20s linear infinite;
    }

    .rotating {
      animation: rotate 4s linear infinite;
    }

    .game-title {
      position: relative;
      font-family: 'Press Start 2P', cursive;
      font-size: 3.5rem;
      background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 3px 3px 0px rgba(0,0,0,0.2);
      animation: rainbow 8s linear infinite;
    }

    .start-screen-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
      overflow: hidden;
      z-index: -1;
    }

    .floating-pipes {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .floating-pipe {
      position: absolute;
      background: linear-gradient(90deg, #4CAF50, #388E3C);
      border-radius: 5px;
      opacity: 0.3;
      transform-origin: center;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    @keyframes glow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
    }

    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes slide {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-100%); }
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    .control-key {
      background: #fff;
      color: #000;
      padding: 10px 20px;
      border-radius: 5px;
      font-weight: bold;
      box-shadow: 0 4px #999;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .control-key:hover {
      transform: translateY(2px);
      box-shadow: 0 2px #666;
    }

    @media (max-width: 768px) {
      .tips-container {
        width: 60%;
        min-width: 200px;
        font-size: 0.9em;
      }
    }

    /* Game Over Screen Styling */
    #gameOverScreen {
      text-align: center;
    }

    .performance-stats {
      background: rgba(0, 0, 0, 0.5);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .highlight-text {
      color: #ffd700;
      font-weight: bold;
      font-size: 1.2em;
    }

    .motivation-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      max-width: 600px;
    }

    .motivation-text {
      color: #4CAF50;
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
    }

    .fact-text {
      color: #2196F3;
      font-style: italic;
      margin: 10px 0;
    }

    /* Add theme-specific UI styles */
    .theme-ui-colors {
      transition: all 0.3s ease;
    }

    /* Update the pause screen */
    #pauseScreen {
      background: linear-gradient(145deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 20, 0.9));
      backdrop-filter: blur(15px);
    }

    #pauseScreen h2 {
      font-family: 'Press Start 2P', cursive;
      font-size: 2.5em;
      margin-bottom: 30px;
      background: linear-gradient(45deg, #ff6b6b, #ffd93d);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    #pauseScreen p {
      font-size: 1.2em;
      margin-bottom: 30px;
      color: #fff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    /* Add pulse animation for pause button */
    @keyframes pausePulse {
      0% { transform: scale(1); box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4); }
      50% { transform: scale(1.05); box-shadow: 0 4px 20px rgba(255, 71, 87, 0.6); }
      100% { transform: scale(1); box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4); }
    }

    #pauseButton.pulsing {
      animation: pausePulse 2s infinite;
    }
  </style>
</head>
<body>
  <!-- Start Screen -->
  <div id="startScreen" class="menu">
    <div class="start-screen-bg">
      <div class="floating-pipes" id="floatingPipes"></div>
    </div>
    
    <h1 class="game-title floating">DON'T FALL</h1>
    
    <div class="how-to-play rainbow-border glowing">
      <h2 class="retro-text">HOW TO PLAY</h2>
      
      <div class="controls">
        <div class="control-key bouncing">SPACE</div>
        <div class="control-key bouncing">CLICK</div>
        <div class="control-key bouncing">TAP</div>
      </div>
      
      <div class="retro-text">
        <p>↑ Use any control to JUMP</p>
        <p>⚠️ Avoid hitting pipes and boundaries</p>
        <p>❤️ You have 3 strikes before Game Over</p>
        <p>🏆 Score points by passing through pipes</p>
      </div>
    </div>

    <button onclick="startGame()" class="rainbow-border">START GAME</button>
    <button onclick="loadSettings()" class="glowing">GAME SETTINGS</button>

    <div class="tips-container">
      <p id="gameTip" class="retro-text"></p>
    </div>
  </div>
  
  <!-- Pause Screen -->
  <div id="pauseScreen" class="menu hidden">
    <h2>Game Paused</h2>
    <p>Press "P" or click Resume to continue.</p>
    <button onclick="togglePause()">Resume</button>
    <button onclick="goToMainMenu()">Main Menu</button>
  </div>
  
  <!-- Game Over Screen -->
  <div id="gameOverScreen" class="menu hidden">
    <h1>GAME OVER</h1>
    <div class="performance-stats">
      <p>Your Score: <span id="finalScore" class="highlight-text"></span></p>
      <p>Best Score: <span id="bestScore" class="highlight-text"></span></p>
      <p>Total Pipes Passed: <span id="pipesPassedCount" class="highlight-text"></span></p>
      <p>Survival Time: <span id="survivalTime" class="highlight-text"></span></p>
    </div>
    
    <div class="motivation-box">
      <p id="motivationalMessage" class="motivation-text"></p>
      <p id="performanceFact" class="fact-text"></p>
    </div>
    
    <h3>Leaderboard:</h3>
    <div id="leaderboard"></div>
    <button onclick="startGame()">Play Again</button>
    <button onclick="goToMainMenu()">Main Menu</button>
  </div>
  
  <!-- Settings Screen -->
  <div id="settingsScreen" class="menu hidden">
    <h1>Game Settings</h1>
    <label>
      Pipe Speed:
      <input type="range" id="pipeSpeedInput" min="1" max="10" step="0.1" value="1.5">
    </label>
    <label>
      Pipe Gap:
      <input type="range" id="pipeGapInput" min="100" max="400" step="10" value="200">
    </label>
    <label>
      Pipe Width:
      <input type="range" id="pipeWidthInput" min="20" max="100" step="5" value="50">
    </label>
    <label>
      Jump Impulse:
      <input type="range" id="jumpImpulseInput" min="3" max="12" step="0.5" value="4">
    </label>
    <label>
      Gravity:
      <input type="range" id="gravityInput" min="0.05" max="0.5" step="0.05" value="0.15">
    </label>
    <label>
      Ball Size:
      <input type="range" id="ballSizeInput" min="8" max="30" step="1" value="12">
    </label>
    <label>
      Ball Color:
      <input type="color" id="ballColorInput" value="#ffff00">
    </label>
    <label>
      Background Color:
      <input type="color" id="bgColorInput" value="#a7d5f7">
    </label>
    <label>
      Game Theme:
      <select id="gameThemeInput">
        <option value="random">Random</option>
        <option value="default">Default</option>
        <option value="night">Night</option>
        <option value="forest">Forest</option>
        <option value="ocean">Ocean</option>
        <option value="desert">Desert</option>
        <option value="space">Space</option>
        <option value="cyber">Cyber</option>
        <option value="candy">Candy Land</option>
        <option value="sunset">Sunset</option>
        <option value="neon">Neon</option>
        <option value="rainbow">Rainbow</option>
        <option value="monochrome">Monochrome</option>
        <option value="retro">Retro</option>
        <option value="volcano">Volcano</option>
        <option value="winter">Winter</option>
        <option value="galaxy">Galaxy</option>
        <option value="underwater">Underwater</option>
        <option value="matrix">Matrix</option>
        <option value="pastel">Pastel</option>
        <option value="halloween">Halloween</option>
        <option value="christmas">Christmas</option>
        <option value="synthwave">Synthwave</option>
      </select>
    </label>
    <label>
      Pipe Color Mode:
      <select id="pipeColorModeInput">
        <option value="theme">Theme Colors</option>
        <option value="random">Random Colors</option>
        <option value="custom">Custom Color</option>
      </select>
    </label>
    <label id="customPipeColorLabel" style="display: none;">
      Custom Pipe Color:
      <input type="color" id="pipeColorInput" value="#4CAF50">
    </label>
    <label>
      Enable Animations:
      <input type="checkbox" id="animationsInput" checked>
    </label>
    <label>
      Music Volume:
      <input type="range" id="musicVolumeInput" min="0" max="1" step="0.1" value="0.5">
    </label>
    <label>
      Sound Effects Volume:
      <input type="range" id="sfxVolumeInput" min="0" max="1" step="0.1" value="0.7">
    </label>
    <label>
      Enable Music:
      <input type="checkbox" id="enableMusicInput" checked>
    </label>
    <button onclick="saveSettings()">Save & Back</button>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  
  <!-- In-Game UI -->
  <div id="gameUI" style="display:none;">
    <div id="scoreDisplay">Score: 0</div>
    <div id="strikesDisplay">Strikes: 0/3</div>
    <div>
      <button id="pauseButton" onclick="togglePause()">Pause</button>
      <button id="settingsButton" onclick="loadSettings()">Settings</button>
    </div>
  </div>
  
  <!-- Sound Effects -->
  <audio id="jumpSound" src="assets/jump.mp3"></audio>
  <audio id="collisionSound" src="assets/collision.mp3"></audio>
  
  <!-- Add theme music elements -->
  <audio id="defaultTheme" src="assets/music/default.mp3" loop></audio>
  <audio id="nightTheme" src="assets/music/night.mp3" loop></audio>
  <audio id="forestTheme" src="assets/music/forest.mp3" loop></audio>
  <audio id="oceanTheme" src="assets/music/ocean.mp3" loop></audio>
  <audio id="desertTheme" src="assets/music/desert.mp3" loop></audio>
  <audio id="spaceTheme" src="assets/music/space.mp3" loop></audio>
  <audio id="cyberTheme" src="assets/music/cyber.mp3" loop></audio>
  <audio id="candyTheme" src="assets/music/candy.mp3" loop></audio>
  <audio id="sunsetTheme" src="assets/music/sunset.mp3" loop></audio>
  <audio id="neonTheme" src="assets/music/neon.mp3" loop></audio>
  <audio id="rainbowTheme" src="assets/music/rainbow.mp3" loop></audio>
  <audio id="monochromeTheme" src="assets/music/monochrome.mp3" loop></audio>
  <audio id="retroTheme" src="assets/music/retro.mp3" loop></audio>
  <audio id="volcanoTheme" src="assets/music/volcano.mp3" loop></audio>
  <audio id="winterTheme" src="assets/music/winter.mp3" loop></audio>
  <audio id="galaxyTheme" src="assets/music/galaxy.mp3" loop></audio>
  <audio id="underwaterTheme" src="assets/music/underwater.mp3" loop></audio>
  <audio id="matrixTheme" src="assets/music/matrix.mp3" loop></audio>
  <audio id="pastelTheme" src="assets/music/pastel.mp3" loop></audio>
  <audio id="halloweenTheme" src="assets/music/halloween.mp3" loop></audio>
  <audio id="christmasTheme" src="assets/music/christmas.mp3" loop></audio>
  <audio id="synthwaveTheme" src="assets/music/synthwave.mp3" loop></audio>
  
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Game state variables
    let ball, pipes, score, bestScore = 0, strikes;
    let frameCount = 0;
    let gameRunning = false;
    let gamePaused = false;
    let bgX = 0;
    
    // Effect variables
    let collisionFlash = 0;  // Maximum opacity ~0.3 for a subtle effect
    let shakeTime = 0;
    let shakeIntensity = 0;
    
    // Leaderboard stored in localStorage
    const leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
    
    // Add these new variables after the other game state variables
    let particles = [];
    let scorePopups = [];
    let rainbowHue = 0; // For rainbow theme animations
    let stars = [];
    let bubbles = [];
    let snowflakes = [];
    let leaves = [];
    let matrixChars = [];
    
    // Default settings with full customization options
    let settings = {
      pipeSpeed: 1.5,
      pipeGap: 200,
      pipeWidth: 50,
      jumpImpulse: -4, // Negative value for upward movement
      gravity: 0.15,
      ballSize: 12,
      ballColor: "#ffff00",
      backgroundColor: "#a7d5f7",
      theme: "default",
      pipeColorMode: "theme",
      customPipeColor: "#4CAF50",
      animations: true,
      originalTheme: "default"
    };
    
    // Responsive Canvas Setup
    function resizeCanvas() {
      if (window.innerWidth < 600) {
        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.7;
      } else {
        canvas.width = window.innerWidth * 0.8;
        canvas.height = window.innerHeight * 0.8;
      }
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    // In-game UI display functions
    function showGameUI() {
      document.getElementById("gameUI").style.display = "flex";
    }
    function hideGameUI() {
      document.getElementById("gameUI").style.display = "none";
    }
    function updateStrikesDisplay() {
      const strikesDisplay = document.getElementById("strikesDisplay");
      strikesDisplay.textContent = "Strikes: " + strikes + "/3";
      
      // Add warning effect when strikes increase
      if (strikes > 0) {
        strikesDisplay.classList.add("strike-warning");
        setTimeout(() => strikesDisplay.classList.remove("strike-warning"), 500);
      }
      
      // Change color intensity based on strikes
      const intensity = (strikes / 3) * 100;
      strikesDisplay.style.color = `hsl(0, ${intensity}%, 60%)`;
    }
    
    // Add this new Particle class before the game functions
    class Particle {
      constructor(x, y, type = 'trail') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 1;
        this.decay = Math.random() * 0.02 + 0.02;
        
        if (type === 'trail') {
          this.size = Math.random() * 3 + 2;
          this.speedX = (Math.random() - 0.5) * 2;
          this.speedY = (Math.random() - 0.5) * 2;
          this.color = settings.ballColor;
        } else if (type === 'collision') {
          this.size = Math.random() * 5 + 3;
          this.speedX = (Math.random() - 0.5) * 10;
          this.speedY = (Math.random() - 0.5) * 10;
          this.color = getCollisionColor();
        }
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= this.decay;
        if (this.type === 'trail') {
          this.size *= 0.95;
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class ScorePopup {
      constructor(x, y, score) {
        this.x = x;
        this.y = y;
        this.score = score;
        this.life = 1;
        this.velocity = -2;
      }

      update() {
        this.y += this.velocity;
        this.life -= 0.02;
      }

      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`+${this.score}`, this.x, this.y);
        ctx.restore();
      }
    }
    
    // Initialize background elements
    function initBackgroundElements() {
      // Create stars for space/galaxy themes
      stars = Array.from({length: 100}, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 1,
        twinkle: Math.random()
      }));
      
      // Create bubbles for underwater theme
      bubbles = Array.from({length: 20}, () => ({
        x: Math.random() * canvas.width,
        y: canvas.height + Math.random() * 20,
        size: Math.random() * 8 + 4,
        speed: Math.random() * 2 + 1
      }));
      
      // Create snowflakes for winter theme
      snowflakes = Array.from({length: 50}, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 3 + 2,
        speed: Math.random() * 2 + 1,
        angle: Math.random() * Math.PI * 2
      }));
      
      // Create leaves for forest theme
      leaves = Array.from({length: 30}, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 5 + 3,
        rotation: Math.random() * Math.PI * 2,
        speed: Math.random() * 2 + 1
      }));
      
      // Create matrix characters
      matrixChars = Array.from({length: 50}, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        speed: Math.random() * 3 + 2,
        char: String.fromCharCode(0x30A0 + Math.random() * 96)
      }));
    }
    
    // Update the drawBackground function
    function drawBackground() {
      bgX -= settings.pipeSpeed;
      if (bgX <= -canvas.width) bgX = 0;
      
      if (!settings.animations) {
        ctx.fillStyle = settings.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }
      
      switch (settings.theme) {
        case "space":
        case "galaxy":
          // Space/Galaxy background with twinkling stars
          const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          gradient.addColorStop(0, settings.theme === "space" ? "#0b0c10" : "#000033");
          gradient.addColorStop(1, settings.theme === "space" ? "#1f2833" : "#191970");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          stars.forEach(star => {
            star.twinkle = Math.sin(frameCount * 0.05 + star.x) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${star.twinkle})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
            
            star.x -= settings.pipeSpeed * 0.5;
            if (star.x < 0) star.x = canvas.width;
          });
          break;

        case "underwater":
          // Underwater background with bubbles
          ctx.fillStyle = settings.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          bubbles.forEach(bubble => {
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.stroke();
            
            bubble.y -= bubble.speed;
            bubble.x += Math.sin(frameCount * 0.05) * 0.5;
            
            if (bubble.y < -bubble.size) {
              bubble.y = canvas.height + bubble.size;
              bubble.x = Math.random() * canvas.width;
            }
          });
          break;

        case "winter":
          // Winter background with falling snow
          ctx.fillStyle = settings.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          snowflakes.forEach(snow => {
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(snow.x, snow.y, snow.size, 0, Math.PI * 2);
            ctx.fill();
            
            snow.y += snow.speed;
            snow.x += Math.sin(snow.angle) * 0.5;
            snow.angle += 0.02;
            
            if (snow.y > canvas.height) {
              snow.y = -snow.size;
              snow.x = Math.random() * canvas.width;
            }
          });
          break;

        case "forest":
          // Forest background with falling leaves
          ctx.fillStyle = settings.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          leaves.forEach(leaf => {
            ctx.save();
            ctx.translate(leaf.x, leaf.y);
            ctx.rotate(leaf.rotation);
            
            ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
            ctx.beginPath();
            ctx.moveTo(0, -leaf.size);
            ctx.quadraticCurveTo(leaf.size, 0, 0, leaf.size);
            ctx.quadraticCurveTo(-leaf.size, 0, 0, -leaf.size);
            ctx.fill();
            
            ctx.restore();
            
            leaf.y += leaf.speed;
            leaf.x += Math.sin(leaf.rotation) * 0.5;
            leaf.rotation += 0.02;
            
            if (leaf.y > canvas.height) {
              leaf.y = -leaf.size;
              leaf.x = Math.random() * canvas.width;
            }
          });
          break;

        case "matrix":
          // Matrix digital rain
          ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.fillStyle = "#00ff41";
          ctx.font = "14px monospace";
          
          matrixChars.forEach(char => {
            if (Math.random() < 0.1) {
              char.char = String.fromCharCode(0x30A0 + Math.random() * 96);
            }
            ctx.fillText(char.char, char.x, char.y);
            
            char.y += char.speed;
            if (char.y > canvas.height) {
              char.y = 0;
              char.x = Math.random() * canvas.width;
            }
          });
          break;

        case "synthwave":
          // Synthwave grid background
          ctx.fillStyle = "#120458";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw sun
          const sunGradient = ctx.createRadialGradient(
            canvas.width/2, canvas.height * 0.8, 0,
            canvas.width/2, canvas.height * 0.8, canvas.height * 0.4
          );
          sunGradient.addColorStop(0, "#ff6b6b");
          sunGradient.addColorStop(1, "transparent");
          ctx.fillStyle = sunGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw grid
          ctx.strokeStyle = "#ff00ff";
          ctx.lineWidth = 1;
          const gridSize = 50;
          const perspective = canvas.height * 0.8;
          
          for (let x = -gridSize; x < canvas.width + gridSize; x += gridSize) {
            const offset = (bgX % gridSize);
            ctx.beginPath();
            ctx.moveTo(x - offset, canvas.height);
            ctx.lineTo(x - offset + (canvas.width/2 - x + offset) * 0.5, perspective);
            ctx.stroke();
          }
          
          for (let y = perspective; y <= canvas.height; y += gridSize) {
            const lineWidth = ((y - perspective) / (canvas.height - perspective));
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.strokeStyle = `rgba(255, 0, 255, ${lineWidth * 0.5})`;
            ctx.stroke();
          }
          break;

        case "random":
          // Create a unique random background effect
          ctx.fillStyle = settings.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          if (settings.animations) {
            // Random pattern effect
            for (let i = 0; i < canvas.width; i += 30) {
              for (let j = 0; j < canvas.height; j += 30) {
                ctx.fillStyle = `hsla(${(frameCount + i + j) % 360}, 70%, 50%, 0.1)`;
                ctx.fillRect(i, j, 15, 15);
              }
            }
          }
          break;

        default:
          // Default animated background
          ctx.fillStyle = settings.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
          for (let i = 0; i < canvas.width; i += 50) {
            ctx.fillRect((bgX + i) % canvas.width, 0, 25, canvas.height);
          }
      }
    }
    
    // Initialize or restart the game
    function initGame() {
      // Check if original theme was random and randomize if needed
      if (settings.originalTheme === "random") {
        randomizeTheme();
      }
      
      ball = {
        x: 100,
        y: canvas.height / 2,
        radius: settings.ballSize,
        velocity: 0,
        color: settings.ballColor
      };
      pipes = [];
      score = 0;
      strikes = 0;
      frameCount = 0;
      gameRunning = true;
      collisionFlash = 0;
      shakeTime = 0;
      updateStrikesDisplay();
      initBackgroundElements();
      updateUIColors();
      
      playThemeMusic(settings.theme);
    }
    
    // Spawn a new pipe with a random gap position
    function spawnPipe() {
      let pipeColors;
      
      if (settings.theme === "random") {
        pipeColors = getRandomPipeColors();
      } else if (settings.pipeColorMode === "theme") {
        pipeColors = getThemeColors();
      } else if (settings.pipeColorMode === "custom") {
        const baseColor = settings.customPipeColor;
        pipeColors = [
          baseColor,
          shadeColor(baseColor, -20),
          shadeColor(baseColor, -40)
        ];
      } else { // random mode
        const hue = Math.floor(Math.random() * 360);
        pipeColors = [
          `hsl(${hue}, 70%, 50%)`,
          `hsl(${hue}, 70%, 40%)`,
          `hsl(${hue}, 70%, 30%)`
        ];
      }

      const gapStart = Math.random() * (canvas.height - settings.pipeGap - 50) + 25;
      pipes.push({
        x: canvas.width,
        top: gapStart,
        bottom: gapStart + settings.pipeGap,
        width: settings.pipeWidth,
        scored: false,
        colors: {
          light: pipeColors[0],
          base: pipeColors[1],
          dark: pipeColors[2]
        }
      });
    }
    
    // Draw the ball
    function drawBall() {
      // Create gradient
      const gradient = ctx.createRadialGradient(
          ball.x - ball.radius/3, 
          ball.y - ball.radius/3,
          ball.radius/4,
          ball.x,
          ball.y,
          ball.radius
      );
      
      // Add gradient colors
      gradient.addColorStop(0, '#fff'); // Highlight
      gradient.addColorStop(0.1, ball.color); // Main color
      gradient.addColorStop(1, shadeColor(ball.color, -30)); // Darker shade
      
      // Draw main ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Add shine effect
      ctx.beginPath();
      ctx.arc(
          ball.x - ball.radius/3,
          ball.y - ball.radius/3,
          ball.radius/3,
          0,
          Math.PI * 2
      );
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fill();
    }
    
    // Helper function to shade colors
    function shadeColor(color, percent) {
        let R = parseInt(color.substring(1,3),16);
        let G = parseInt(color.substring(3,5),16);
        let B = parseInt(color.substring(5,7),16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R<255)?R:255;  
        G = (G<255)?G:255;  
        B = (B<255)?B:255;  

        const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
        const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
        const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

        return "#"+RR+GG+BB;
    }
    
    // Draw each pipe
    function drawPipes() {
      pipes.forEach(pipe => {
        // For each pipe section (top and bottom)
        [
          { y: 0, height: pipe.top },
          { y: pipe.bottom, height: canvas.height - pipe.bottom }
        ].forEach(section => {
          // Main pipe body
          const pipeGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipe.width, 0);
          pipeGradient.addColorStop(0, pipe.colors.light);  // Bright shade
          pipeGradient.addColorStop(0.3, pipe.colors.base); // Medium shade
          pipeGradient.addColorStop(1, pipe.colors.dark);   // Dark shade
          
          // Draw main pipe body
          ctx.fillStyle = pipeGradient;
          ctx.fillRect(pipe.x, section.y, pipe.width, section.height);
          
          // Draw pipe rim (top and bottom of each section)
          const rimHeight = pipe.width * 0.15;
          const rimGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipe.width, 0);
          rimGradient.addColorStop(0, pipe.colors.light);
          rimGradient.addColorStop(0.3, pipe.colors.base);
          rimGradient.addColorStop(1, pipe.colors.dark);
          
          ctx.fillStyle = rimGradient;
          if (section.y === 0) {
            // Bottom rim for top pipe
            ctx.fillRect(pipe.x - 5, section.y + section.height - rimHeight, pipe.width + 10, rimHeight);
          } else {
            // Top rim for bottom pipe
            ctx.fillRect(pipe.x - 5, section.y, pipe.width + 10, rimHeight);
          }
          
          // Add highlight
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(pipe.x, section.y, pipe.width * 0.15, section.height);
          
          // Add shadow line
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.fillRect(pipe.x + pipe.width - 2, section.y, 2, section.height);
          
          // Add rim highlights and shadows
          if (section.y === 0) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(pipe.x - 5, section.y + section.height - rimHeight, pipe.width + 10, 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(pipe.x - 5, section.y + section.height - 2, pipe.width + 10, 2);
          } else {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(pipe.x - 5, section.y, pipe.width + 10, 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(pipe.x - 5, section.y + rimHeight - 2, pipe.width + 10, 2);
          }
          
          // Add subtle texture details (small rectangles)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
          for (let i = 0; i < 2; i++) {
            const x = pipe.x + pipe.width * 0.3 + (i * pipe.width * 0.2);
            const y = section.y + (section.height * 0.3);
            ctx.fillRect(x, y, 4, 4);
          }
        });
      });
    }
    
    // Draw a transparent collision effect overlay (subtle white)
    function drawCollisionEffect() {
      if (collisionFlash > 0) {
        ctx.save();
        ctx.globalAlpha = collisionFlash;
        ctx.fillStyle = getCollisionColor();
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        collisionFlash -= 0.01;
      }
    }
    
    // When a collision is detected, increment strikes and either respawn or end the game.
    function triggerCollision() {
      playSound("collisionSound");
      collisionFlash = 0.3;
      shakeTime = 10;
      shakeIntensity = 5;
      
      // Add collision particles
      if (settings.animations) {
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(ball.x, ball.y, 'collision'));
        }
      }
      
      strikes++;
      updateStrikesDisplay();
      if (strikes < 4) {
        respawnBall();
      } else {
        gameOver();
      }
    }
    
    // Check for collisions with boundaries and pipes
    function handleCollision() {
      // Check top/bottom boundaries
      if (ball.y + ball.radius >= canvas.height || ball.y - ball.radius <= 0) {
        triggerCollision();
        return;
      }
      // Check collision with pipes
      for (let pipe of pipes) {
        if (
          ball.x + ball.radius > pipe.x &&
          ball.x - ball.radius < pipe.x + pipe.width &&
          (ball.y - ball.radius < pipe.top || ball.y + ball.radius > pipe.bottom)
        ) {
          triggerCollision();
          return;
        }
      }
    }
    
    // Increase score when ball passes a pipe
    function updateScore() {
      pipes.forEach(pipe => {
        if (!pipe.scored && pipe.x + pipe.width < ball.x) {
          score++;
          pipe.scored = true;
          
          // Add score pulse effect
          const scoreDisplay = document.getElementById("scoreDisplay");
          scoreDisplay.textContent = "Score: " + score;
          scoreDisplay.classList.add("score-change");
          setTimeout(() => scoreDisplay.classList.remove("score-change"), 300);
        }
      });
    }
    
    // Respawn the ball after a collision (if strikes are less than 4)
    function respawnBall() {
      if (settings.originalTheme === "random") {
        randomizeTheme();
        applyThemeOverrides();
      }
      
      ball.x = 100;
      ball.y = canvas.height / 2;
      ball.velocity = 0;
      ball.color = settings.ballColor; // Update ball color for new theme
      pipes = [];
      frameCount = 0;
      initBackgroundElements(); // Reinitialize background elements for new theme
    }
    
    // End the game
    function gameOver() {
      gameRunning = false;
      hideGameUI();
      
      // Calculate performance stats
      const pipesPassedCount = score;
      const survivalTimeSeconds = Math.floor(frameCount / 60); // Assuming 60 FPS
      const survivalTimeFormatted = `${Math.floor(survivalTimeSeconds / 60)}m ${survivalTimeSeconds % 60}s`;
      
      // Update best score
      if (score > bestScore) bestScore = score;
      
      // Update leaderboard
      updateLeaderboard(score);
      displayLeaderboard();
      
      // Update display elements
      document.getElementById("finalScore").textContent = score;
      document.getElementById("bestScore").textContent = bestScore;
      document.getElementById("pipesPassedCount").textContent = pipesPassedCount;
      document.getElementById("survivalTime").textContent = survivalTimeFormatted;
      
      // Show random motivation message and performance fact
      document.getElementById("motivationalMessage").textContent = 
        motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
      document.getElementById("performanceFact").textContent = 
        performanceFacts[Math.floor(Math.random() * performanceFacts.length)];
      
      // Show game over screen
      document.getElementById("gameOverScreen").classList.remove("hidden");
      
      // Stop the music
      if (currentMusic) {
        currentMusic.pause();
        currentMusic.currentTime = 0;
      }
    }
    
    // Leaderboard functions
    function updateLeaderboard(score) {
      leaderboard.push(score);
      leaderboard.sort((a, b) => b - a).splice(5);
      localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
    }
    function displayLeaderboard() {
      const leaderboardList = leaderboard
        .map((score, i) => `<p>${i + 1}. ${score}</p>`)
        .join("");
      document.getElementById("leaderboard").innerHTML = leaderboardList;
    }
    
    // Play a sound effect
    function playSound(soundId) {
      const sound = document.getElementById(soundId);
      sound.currentTime = 0;
      sound.play();
    }
    
    // Main game loop
    function gameLoop() {
      if (!gameRunning || gamePaused) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Apply screen shake
      ctx.save();
      if (shakeTime > 0) {
        const offsetX = (Math.random() - 0.5) * shakeIntensity;
        const offsetY = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(offsetX, offsetY);
        shakeTime--;
      }
      
      drawBackground();
      
      // Update ball physics
      ball.velocity += settings.gravity;
      ball.y += ball.velocity;
      
      // Add trail particles
      if (settings.animations && frameCount % 2 === 0) {
        particles.push(new Particle(ball.x, ball.y, 'trail'));
      }
      
      // Update and draw particles
      particles = particles.filter(particle => {
        particle.update();
        particle.draw(ctx);
        return particle.life > 0;
      });
      
      // Update and draw score popups
      scorePopups = scorePopups.filter(popup => {
        popup.update();
        popup.draw(ctx);
        return popup.life > 0;
      });
      
      // Spawn pipes periodically
      if (frameCount++ % 100 === 0) spawnPipe();
      
      // Move and remove pipes
      pipes.forEach(pipe => pipe.x -= settings.pipeSpeed);
      pipes = pipes.filter(pipe => {
        if (!pipe.scored && pipe.x + pipe.width < ball.x) {
          score++;
          pipe.scored = true;
          // Add score popup
          scorePopups.push(new ScorePopup(ball.x, ball.y - 30, 1));
        }
        return pipe.x + pipe.width > 0;
      });
      
      drawBall();
      drawPipes();
      handleCollision();
      
      ctx.restore();
      
      // Draw collision flash overlay
      drawCollisionEffect();
      
      // Update UI
      document.getElementById("scoreDisplay").textContent = "Score: " + score;
      
      requestAnimationFrame(gameLoop);
    }
    
    // Start a new game
    function startGame() {
      document.querySelectorAll(".menu").forEach(menu => menu.classList.add("hidden"));
      showGameUI();
      initGame();
      gameLoop();
    }
    
    // Toggle pause/resume
    function togglePause() {
      gamePaused = !gamePaused;
      const pauseButton = document.getElementById("pauseButton");
      const pauseScreen = document.getElementById("pauseScreen");
      
      if (gamePaused) {
        pauseScreen.classList.remove("hidden");
        pauseButton.style.background = "linear-gradient(45deg, #ff8e8e, #ff6b6b)";
        pauseButton.textContent = "Resume";
        pauseButton.classList.add("pulsing");
        // Pause music
        if (currentMusic) {
          currentMusic.pause();
        }
      } else {
        pauseScreen.classList.add("hidden");
        pauseButton.style.background = "linear-gradient(45deg, #ff6b6b, #ff8e8e)";
        pauseButton.textContent = "Pause";
        pauseButton.classList.remove("pulsing");
        // Resume music
        if (currentMusic && settings.enableMusic) {
          currentMusic.play().catch(error => console.log("Music autoplay prevented:", error));
        }
        gameLoop();
      }
    }
    
    // Return to main menu
    function goToMainMenu() {
      hideGameUI();
      document.querySelectorAll(".menu").forEach(menu => menu.classList.add("hidden"));
      document.getElementById("startScreen").classList.remove("hidden");
      gameRunning = false;
      gamePaused = false;
      // Clean up any temporary state
      if (settings.tempState) {
        delete settings.tempState;
      }
    }
    
    // Load settings menu
    function loadSettings() {
      if (gameRunning) {
        // Store the current pause state
        const wasPaused = gamePaused;
        // Pause the game if it wasn't already paused
        gamePaused = true;
        
        // Store these states to restore them later
        settings.tempState = {
          wasPaused: wasPaused,
          gameRunning: gameRunning
        };
      }
      
      hideGameUI();
      document.querySelectorAll(".menu").forEach(menu => menu.classList.add("hidden"));
      document.getElementById("settingsScreen").classList.remove("hidden");
    }
    
    // Save settings from the settings menu
    function saveSettings() {
      settings.pipeSpeed = parseFloat(document.getElementById("pipeSpeedInput").value);
      settings.pipeGap = parseInt(document.getElementById("pipeGapInput").value);
      settings.pipeWidth = parseInt(document.getElementById("pipeWidthInput").value);
      settings.jumpImpulse = -parseFloat(document.getElementById("jumpImpulseInput").value);
      settings.gravity = parseFloat(document.getElementById("gravityInput").value);
      settings.ballSize = parseInt(document.getElementById("ballSizeInput").value);
      settings.ballColor = document.getElementById("ballColorInput").value;
      settings.backgroundColor = document.getElementById("bgColorInput").value;
      settings.theme = document.getElementById("gameThemeInput").value;
      settings.originalTheme = settings.theme; // Store the original theme selection
      settings.pipeColorMode = document.getElementById("pipeColorModeInput").value;
      settings.customPipeColor = document.getElementById("pipeColorInput").value;
      settings.animations = document.getElementById("animationsInput").checked;
      settings.musicVolume = parseFloat(document.getElementById("musicVolumeInput").value);
      settings.sfxVolume = parseFloat(document.getElementById("sfxVolumeInput").value);
      settings.enableMusic = document.getElementById("enableMusicInput").checked;
      
      if (settings.theme === "random") {
        randomizeTheme();
      }
      
      // Apply theme overrides
      applyThemeOverrides();
      
      // Restore game state if we were in a game
      if (settings.tempState) {
        // Show game UI if we were in a game
        showGameUI();
        // Restore the previous pause state
        gamePaused = settings.tempState.wasPaused;
        // Resume the game loop if it wasn't paused before
        if (!gamePaused) {
          gameLoop();
        }
        // Clean up the temporary state
        delete settings.tempState;
      } else {
        goToMainMenu();
      }
      
      updateUIColors();
      
      // Update current music volume if playing
      if (currentMusic) {
        currentMusic.volume = settings.musicVolume;
      }
      
      // Update sound effects volume
      document.getElementById("jumpSound").volume = settings.sfxVolume;
      document.getElementById("collisionSound").volume = settings.sfxVolume;
    }
    
    // Add this new function to handle theme randomization
    function randomizeTheme() {
      const newTheme = getRandomTheme();
      settings.theme = newTheme;
      settings.ballColor = getRandomColor();
      settings.backgroundColor = getRandomColor();
      settings.pipeColorMode = ["theme", "random", "custom"][Math.floor(Math.random() * 3)];
      if (settings.pipeColorMode === "custom") {
        settings.customPipeColor = getRandomColor();
      }
    }
    
    // Add this function to apply theme overrides
    function applyThemeOverrides() {
      switch (settings.theme) {
        case "night":
          settings.backgroundColor = "#000000";
          settings.ballColor = "#ffffff";
          break;
        case "forest":
          settings.backgroundColor = "#2e8b57";
          settings.ballColor = "#ffd700";
          break;
        case "ocean":
          settings.backgroundColor = "#1e90ff";
          settings.ballColor = "#ffffff";
          break;
        case "desert":
          settings.backgroundColor = "#EDC9Af";
          settings.ballColor = "#8B4513";
          break;
        case "space":
          settings.backgroundColor = "#0b0c10";
          settings.ballColor = "#66fcf1";
          break;
        case "cyber":
          settings.backgroundColor = "#1a1a2e";
          settings.ballColor = "#e94560";
          break;
        case "candy":
          settings.backgroundColor = "#ffc0cb";
          settings.ballColor = "#ff69b4";
          break;
        case "sunset":
          settings.backgroundColor = "#ff8c00";
          settings.ballColor = "#ff4500";
          break;
        case "neon":
          settings.backgroundColor = "#000000";
          settings.ballColor = "#00ff00";
          break;
        case "rainbow":
          settings.backgroundColor = "#ffffff";
          settings.ballColor = "#ff0000";
          break;
        case "monochrome":
          settings.backgroundColor = "#ffffff";
          settings.ballColor = "#000000";
          break;
        case "retro":
          settings.backgroundColor = "#000000";
          settings.ballColor = "#00ff00";
          break;
        case "volcano":
          settings.backgroundColor = "#300000";
          settings.ballColor = "#ff6600";
          break;
        case "winter":
          settings.backgroundColor = "#e3f2fd";
          settings.ballColor = "#2196f3";
          break;
        case "galaxy":
          settings.backgroundColor = "#000033";
          settings.ballColor = "#ffffff";
          break;
        case "underwater":
          settings.backgroundColor = "#006994";
          settings.ballColor = "#ffd700";
          break;
        case "matrix":
          settings.backgroundColor = "#000000";
          settings.ballColor = "#00ff41";
          break;
        case "pastel":
          settings.backgroundColor = "#f0f8ff";
          settings.ballColor = "#ffb3c6";
          break;
        case "halloween":
          settings.backgroundColor = "#200020";
          settings.ballColor = "#ff6600";
          break;
        case "christmas":
          settings.backgroundColor = "#006400";
          settings.ballColor = "#ff0000";
          break;
        case "synthwave":
          settings.backgroundColor = "#120458";
          settings.ballColor = "#ff00ff";
          break;
      }
    }
    
    // Input events: keyboard and touch support
    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        ball.velocity = settings.jumpImpulse;
        playSound("jumpSound");
      }
      if (e.code === "KeyP") togglePause();
    });
    canvas.addEventListener("click", () => {
      ball.velocity = settings.jumpImpulse;
      playSound("jumpSound");
    });
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      ball.velocity = settings.jumpImpulse;
      playSound("jumpSound");
    });

    // Add this event listener to show/hide custom color input
    document.getElementById("pipeColorModeInput").addEventListener("change", function() {
      const customColorLabel = document.getElementById("customPipeColorLabel");
      customColorLabel.style.display = this.value === "custom" ? "block" : "none";
    });

    // Add this new function to generate theme-based colors:
    function getThemeColors() {
      switch (settings.theme) {
        case "night":
          return ["#2c3e50", "#34495e", "#95a5a6"];
        case "forest":
          return ["#2ecc71", "#27ae60", "#16a085"];
        case "ocean":
          return ["#3498db", "#2980b9", "#1abc9c"];
        case "desert":
          return ["#e67e22", "#d35400", "#f39c12"];
        case "space":
          return ["#8e44ad", "#9b59b6", "#2c3e50"];
        case "cyber":
          return ["#e94560", "#0f3460", "#533483"];
        case "candy":
          return ["#ff6b6b", "#ff8e8e", "#ffd93d"];
        case "sunset":
          return ["#ff7f50", "#ff6b6b", "#ffd700"];
        case "neon":
          return ["#00ff00", "#ff00ff", "#00ffff"];
        case "rainbow":
          return ["#ff0000", "#00ff00", "#0000ff"];
        case "monochrome":
          return ["#404040", "#606060", "#808080"];
        case "retro":
          return ["#00ff00", "#00cc00", "#009900"];
        case "volcano":
          return ["#ff4400", "#cc3300", "#991100"];
        case "winter":
          return ["#a5f2f3", "#8be9eb", "#59d0d3"];
        case "galaxy":
          return ["#663399", "#4b0082", "#800080"];
        case "underwater":
          return ["#00b4d8", "#0096c7", "#0077b6"];
        case "matrix":
          return ["#00ff41", "#008f11", "#003b00"];
        case "pastel":
          return ["#ffd1dc", "#ffb3c6", "#ff8fab"];
        case "halloween":
          return ["#ff6600", "#cc5200", "#993d00"];
        case "christmas":
          return ["#ff0000", "#00aa00", "#ffffff"];
        case "synthwave":
          return ["#ff00ff", "#00ffff", "#ff0066"];
        default:
          return ["#4CAF50", "#388E3C", "#2E7D32"];
      }
    }

    // Add these new functions after the existing functions
    function getRandomTheme() {
      const themes = [
        "default", "night", "forest", "ocean", "desert", "space", "cyber",
        "candy", "sunset", "neon", "rainbow", "monochrome", "retro", "volcano",
        "winter", "galaxy", "underwater", "matrix", "pastel", "halloween",
        "christmas", "synthwave"
      ];
      return themes[Math.floor(Math.random() * themes.length)];
    }

    function getRandomColor() {
      const hue = Math.floor(Math.random() * 360);
      return `hsl(${hue}, 70%, 50%)`;
    }

    // Add this function to get random pipe colors
    function getRandomPipeColors() {
      const hue = Math.floor(Math.random() * 360);
      return [
        `hsl(${hue}, 70%, 50%)`,
        `hsl(${hue}, 70%, 40%)`,
        `hsl(${hue}, 70%, 30%)`
      ];
    }

    // Update the tips array with more engaging and detailed tips
    const tips = [
      "💫 PRO TIP: Tap gently for short jumps, hold longer for higher jumps!",
      "🎯 STRATEGY: Keep your eyes focused ahead to anticipate pipe patterns",
      "🌈 DISCOVER: Each theme has unique visual effects and animations - try them all!",
      "🚀 CHALLENGE: Increase pipe speed in settings for higher score multipliers",
      "🎮 MASTER TIP: Find your rhythm between pipes for perfect timing",
      "⚡ QUICK TIP: Double-tap SPACE to perform quick successive jumps",
      "🎨 CUSTOMIZE: Mix and match themes and colors to create your perfect game",
      "🏆 COMPETE: Share your high scores and challenge your friends!",
      "🔥 STREAK TIP: Build momentum by maintaining consistent height",
      "🎵 RHYTHM: Try playing to the beat of your favorite music",
      "🌟 SECRET: Random theme gives you unique combinations each game!",
      "💪 PRACTICE: Start with slower speeds to master the basics",
      "🎯 FOCUS: Watch the gaps, not the pipes, for better accuracy",
      "🔄 RECOVERY: Stay calm after a strike - you have 3 chances!",
      "⚔️ ADVANCED: Try extreme settings for an ultimate challenge",
      "🎪 STYLE: Show off by passing through the center of gaps",
      "🌈 THEMES: Each theme has its own personality - find your favorite!",
      "🎮 CONTROL: Master both mouse and keyboard for different situations",
      "🏃 MOMENTUM: Keep a steady pace through consecutive pipes",
      "🌟 PERFECT: Aim for clean runs without hitting any pipes!"
    ];

    // Update the tip display function to remove fade animation
    function updateTip() {
      const gameTip = document.getElementById('gameTip');
      const randomTip = tips[Math.floor(Math.random() * tips.length)];
      
      // Just update the content with styling
      gameTip.innerHTML = `<span style="color: #ffeb3b; font-weight: bold;">${randomTip}</span>`;
    }

    // Update tip every 5 seconds
    setInterval(updateTip, 5000);
    updateTip(); // Show first tip immediately

    // Create floating background pipes
    function createFloatingPipes() {
      const container = document.getElementById('floatingPipes');
      const numPipes = 15;
      
      for (let i = 0; i < numPipes; i++) {
        const pipe = document.createElement('div');
        pipe.className = 'floating-pipe';
        
        // Random size and position
        const width = Math.random() * 100 + 50;
        const height = Math.random() * 200 + 100;
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        
        pipe.style.width = `${width}px`;
        pipe.style.height = `${height}px`;
        pipe.style.left = `${left}%`;
        pipe.style.top = `${top}%`;
        
        // Random animation
        const duration = Math.random() * 10 + 5;
        const delay = Math.random() * -10;
        pipe.style.animation = `float ${duration}s ease-in-out infinite ${delay}s`;
        
        container.appendChild(pipe);
      }
    }

    // Initialize floating pipes when the page loads
    window.addEventListener('load', createFloatingPipes);

    // Add hover effect to control keys
    document.querySelectorAll('.control-key').forEach(key => {
      key.addEventListener('mouseenter', () => {
        key.style.transform = 'translateY(2px)';
        key.style.boxShadow = '0 2px #666';
      });
      
      key.addEventListener('mouseleave', () => {
        key.style.transform = '';
        key.style.boxShadow = '';
      });
    });

    // Add this new function to get theme-specific collision colors
    function getCollisionColor() {
      switch (settings.theme) {
        case "night":
          return '#4a69bd';
        case "forest":
          return '#78e08f';
        case "ocean":
          return '#60a3bc';
        case "desert":
          return '#fa983a';
        case "space":
          return '#9c88ff';
        case "cyber":
          return '#e94560';
        case "neon":
          return '#0be881';
        case "rainbow":
          return `hsl(${Math.random() * 360}, 100%, 70%)`;
        case "matrix":
          return '#00ff41';
        case "synthwave":
          return '#ff00ff';
        case "volcano":
          return '#ff5252';
        case "winter":
          return '#70a1ff';
        case "underwater":
          return '#34e7e4';
        case "halloween":
          return '#ffa502';
        case "christmas":
          return '#ff4757';
        default:
          return '#ff4444';
      }
    }

    // Add these arrays for motivational messages and performance facts
    const motivationalMessages = [
      "Great effort! Every attempt makes you stronger! 💪",
      "You're getting better with each try! 🌟",
      "That was an impressive run! Ready for another? 🚀",
      "Keep pushing your limits! You're improving! 🎯",
      "Success is built on persistence! Keep going! ⭐",
      "You're developing pro skills! Don't give up! 🏆",
      "Amazing progress! Can you beat this score? 🎮",
      "Every game makes you better! One more try? 💫",
      "You're showing real potential! Keep practicing! 🌟",
      "That's the spirit! Success is just ahead! 🎯"
    ];

    const performanceFacts = [
      "Did you know? The world's best players started just like you!",
      "Fun fact: Regular players improve their reaction time by 20%!",
      "Tip: Try different themes to find your perfect playing style!",
      "Pro insight: Most top scores are achieved after 50+ attempts!",
      "Game fact: Your brain forms new neural pathways while playing!",
      "Strategy tip: Focus on rhythm rather than individual jumps!",
      "Physics fact: The game helps improve hand-eye coordination!",
      "Player stat: Most players beat their high score within 10 tries!",
      "Game wisdom: Consistent practice leads to consistent scores!",
      "Quick fact: Gaming improves decision-making skills!"
    ];

    // Add this function to update UI colors based on theme
    function updateUIColors() {
      const gameUI = document.getElementById('gameUI');
      const uiElements = document.querySelectorAll('#scoreDisplay, #strikesDisplay, #gameUI button');
      
      // Remove all theme classes
      gameUI.className = '';
      // Add current theme class
      gameUI.classList.add(`theme-${settings.theme}`);
      
      let primaryColor, glowColor, accentColor;
      
      switch (settings.theme) {
        case "neon":
          primaryColor = '#00ff00';
          glowColor = 'rgba(0, 255, 0, 0.7)';
          accentColor = '#00ff00';
          break;
        case "cyber":
          primaryColor = '#e94560';
          glowColor = 'rgba(233, 69, 96, 0.7)';
          accentColor = '#e94560';
          break;
        case "synthwave":
          primaryColor = '#ff00ff';
          glowColor = 'rgba(255, 0, 255, 0.7)';
          accentColor = '#ff00ff';
          break;
        // Add more theme-specific colors...
        default:
          primaryColor = '#ffffff';
          glowColor = 'rgba(255, 255, 255, 0.7)';
          accentColor = '#4CAF50';
      }

      uiElements.forEach(element => {
        element.style.setProperty('--accent-color', accentColor);
        element.style.setProperty('--glow-color', glowColor);
        
        if (element.id === 'scoreDisplay') {
          element.style.borderColor = accentColor;
        } else if (element.id === 'strikesDisplay') {
          // Keep strike display styling
        } else {
          // Buttons get hover effect color
          element.style.setProperty('--hover-color', glowColor);
        }
      });
    }

    // Add button press effect
    document.querySelectorAll('#gameUI button').forEach(button => {
      button.addEventListener('mousedown', () => {
        button.style.transform = 'scale(0.95)';
      });
      
      button.addEventListener('mouseup', () => {
        button.style.transform = '';
      });
      
      button.addEventListener('mouseleave', () => {
        button.style.transform = '';
      });
    });

    // Add these functions after the existing functions in the script section

    // Music management
    let currentMusic = null;

    function playThemeMusic(theme) {
      // Stop current music if playing
      if (currentMusic) {
        currentMusic.pause();
        currentMusic.currentTime = 0;
      }

      // Don't play music if it's disabled
      if (!settings.enableMusic) return;

      // Get the appropriate music element for the theme
      const musicId = theme === 'random' ? getRandomThemeMusic() : `${theme}Theme`;
      const musicElement = document.getElementById(musicId);

      // If music element exists, play it
      if (musicElement) {
        musicElement.volume = settings.musicVolume;
        musicElement.play().catch(error => console.log("Music autoplay prevented:", error));
        currentMusic = musicElement;
      } else {
        // Fallback to default theme if specific theme music doesn't exist
        const defaultMusic = document.getElementById('defaultTheme');
        if (defaultMusic) {
          defaultMusic.volume = settings.musicVolume;
          defaultMusic.play().catch(error => console.log("Music autoplay prevented:", error));
          currentMusic = defaultMusic;
        }
      }
    }

    function getRandomThemeMusic() {
      const themes = [
        'default', 'night', 'forest', 'ocean', 'desert', 'space', 'cyber',
        'candy', 'sunset', 'neon', 'rainbow', 'monochrome', 'retro', 'volcano',
        'winter', 'galaxy', 'underwater', 'matrix', 'pastel', 'halloween',
        'christmas', 'synthwave'
      ];
      return `${themes[Math.floor(Math.random() * themes.length)]}Theme`;
    }

    // Update the settings object to include audio settings
    settings.musicVolume = 0.5;
    settings.sfxVolume = 0.7;
    settings.enableMusic = true;
  </script>
</body>
</html>
